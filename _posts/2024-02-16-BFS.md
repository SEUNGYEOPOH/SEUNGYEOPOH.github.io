---
title:  "BFS"
categories : Algorithm
tag : BFS
# 복수로 하려면 [Python, Blog]처럼 리스트 형태로 할당
toc : true
# toc순서는 markdown header(#) 기준 입니당
toc_sticky : true
toc_label : Content
toc_icon : "fas fa-book-open"
author_profile : false
use_math : true
---

# Breadth-First Search

## 1. What is Breadth-First Search?
- Graph Search
    - Start Node와 Graph가 주어졌을 때 Edge를 통해 방문할 수 있는 Node를 찾는 문제
    - BFS와 DFS가 존재한다.
- BFS(FIFO 사용)
    - Start Node에서 인접 노드 기준으로 탐색
    - 즉 Tree를 수평으로 우선 탐색
    - 최단거리(경로) 해결에 효과적


<p align="center"><img src = "https://github.com/SEUNGYEOPOH/SEUNGYEOPOH/assets/81912557/a63f11de-ced2-44ed-bd0b-638af9bb68e3" width = "50%" height = "50%" ></p>

## 2. How to Use?
- Queue(FIFO)를 활용하여 구현
- 1차원 혹은 2차원 Board에서 이동 가능한 좌표로 이동
- 직전 좌표에서 이동한 거리만큼 노드의 값을 가중시키며 목적지까지의 거리 탐색

## 3. Base Code
### BFS
```python
from collections import deque
n, m = map(int,input().split())
board=[]
for i in range(n):
    board.append(list(map(int,input())))
# 이동량
dx = [-1,1,0,0]
dy = [0,0,-1,1]
arr = deque()
arr.append([0,0])
while arr :
  # 현재 위치
  px, py = arr.popleft()
  # 좌표 이동
  for i in range(len(dx)):
    nx = px+dx[i]
    ny = py+dy[i]
    # board를 벗어나면 continue
    if nx>n-1 or ny>m-1 or nx<0 or ny<0 :
        continue
    # 이동 가능한 좌표라면
    if board[nx][ny]==1:
        # target 좌표로 선정
        arr.append((nx,ny))
        # 좌표 값의 값을 가중하며 거리 계산
        board[nx][ny] = board[px][py]+1 # 직전 노드+1
# 가중된 거리에 따라 마지막 좌표 return
print(board[n-1][m-1])
```

## 4. Example

### 4.1 백준 2178번
#### 4.1.1 문제
![img](https://github.com/SEUNGYEOPOH/CV/assets/81912557/a56d700b-83a3-4bce-9dab-50e1a5008b68)

#### 4.1.2 해답
```python
from collections import deque
n, m = map(int,input().split())
board=[]
for i in range(n):
    board.append(list(map(int,input())))
dx = [-1,1,0,0]
dy = [0,0,-1,1]

arr = deque()
arr.append([0,0])

while arr :
  px, py = arr.popleft()
  for i in range(len(dx)):
    nx = px+dx[i]
    ny = py+dy[i]
    if nx>n-1 or ny>m-1 or nx<0 or ny<0 :
        continue
    if board[nx][ny]==1:
        arr.append((nx,ny))
        board[nx][ny] = board[px][py]+1 
print(board[n-1][m-1])
```

### 4.2 백준 1260번
