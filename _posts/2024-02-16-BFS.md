---
title:  "BFS"
categories : Algorithm
tag : BFS
# 복수로 하려면 [Python, Blog]처럼 리스트 형태로 할당
toc : true
# toc순서는 markdown header(#) 기준 입니당
toc_sticky : true
toc_label : Content
toc_icon : "fas fa-book-open"
author_profile : false
use_math : true
---

# Breadth-First Search

## 1. What is Breadth-First Search?
- Graph Search
    - Start Node와 Graph가 주어졌을 때 Edge를 통해 방문할 수 있는 Node를 찾는 문제
    - BFS와 DFS가 존재한다.
- BFS(FIFO 사용)
    - Start Node에서 인접 노드 기준으로 탐색
    - 즉 Tree를 수평으로 우선 탐색
    - 최단거리(경로) 해결에 효과적


<p align="center"><img src = "https://upload.wikimedia.org/wikipedia/commons/5/5d/Breadth-First-Search-Algorithm.gif?20100504223639" width = "50%" height = "50%" ></p>

## 2. How to Use?
- Queue(FIFO)를 활용하여 구현
- 1차원 혹은 2차원 Board에서 이동 가능한 좌표로 이동
- 직전 좌표에서 이동한 거리만큼 노드의 값을 가중시키며 목적지까지의 거리 탐색

## 3. Base Code
### BFS
```python
from collections import deque

def bfs(node): 
    a=deque([node]) # 초기 노드를 큐에 push
    state[node] = 1 # 방문 처리
    while len(a): # 큐가 빌때까지
        node = a.popleft() # 큐에서 처음 들어온 노드 제거
        ans_2.append(node) # 제거 후 출력 순서를 보여주기 위해 ans에 방문된 node 추가
        for nxt in graph[node]: # 관련된 다른 node
            if state[nxt]==0: # 방문하지 않은 노드일 경우
                a.append(nxt) # 큐에 추가하고
                state[nxt]=1 # 방문 처리

n,m = map(int, input().split()) # n은 노드 개수, m은 간선
graph =[[] for i in range(n+1)] #
ans_2=[]
for i in range(m):
    a,b=map(int,input().split())
    graph[a].append(b)
    graph[b].append(a)

state = [0 for i in range(n+1)] 
bfs(1) # 탐색
print(*ans_2) # 결과 출력



```

## 4. Example


### 4.1 BOJ 18352번 특정 거리의 도시 찾기
#### 4.1.1 문제
![img](https://github.com/SEUNGYEOPOH/SEUNGYEOPOH/assets/81912557/3f503fec-2742-4114-8137-7803c3df6d0d)


#### 4.1.2 해답
```python
from collections import deque
import sys
input = sys.stdin.readline
n,m,k,x = map(int, input().split())
graph = [[] for i in range(n+1)]
state = [-1 for j in range(n+1)]
for i in range(m):
    a,b = map(int, input().split()) # 단방향 그래프 구현을 위해 한 노드에서만 갈 수 있도록
    graph[a].append(b)

for j in range(len(graph)):
    graph[j] = sorted(graph[j]) # 정렬 
    
def bfs(node):
    ans = []
    a=deque([node])
    state[node] = 1 # 스타트를 1로, count로 올리면 순서가 되어버리므로, 현재 노드의 거리를 다음 노드의 +1씩 더해주며 depth 계산
    while len(a):
        node = a.popleft()
        for nxt in graph[node]:
            if state[nxt]==-1:
                a.append(nxt)
                state[nxt]=state[node]+1
                if state[nxt]-1==k: # start를 1로 잡았으므로, -1한 값이 최단거리와 동일한 경우
                    ans.append(nxt) # 정답 리스트에 추가하기
            else:
                continue
    return ans
ans = bfs(x)
ans = sorted(ans) # 오름차순
if len(ans)==0: # return 값이 없다면 -1
    print(-1)
else:
    for i in ans: # 있다면 출력
        print(i)
```


### 4.2 BOJ 11725번 트리의 부모 찾기
#### 4.2.1 문제
![img](https://github.com/SEUNGYEOPOH/SEUNGYEOPOH/assets/81912557/8094d76f-d4af-42ad-9e94-90e5a839914d)


#### 4.2.2 해답
```python
from collections import deque
import sys
input = sys.stdin.readline
m=int(input())
graph = [[] for i in range(m+1)]
state = [False for j in range(m+1)]
for i in range(m-1):
    a,b = map(int, input().split())
    graph[a].append(b)
    graph[b].append(a)
    
for i in range(len(graph)):
    graph[i] = sorted(graph[i])
def bfs(node):
    a=deque([node])
    ans = []
    state[node] = True
    while len(a):
        node = a.popleft()
        for nxt in graph[node]: # nxt는 node의 자식노드
            if state[nxt]==False:
                a.append(nxt) 
                state[nxt]=node # 자식노드의 State는 부모노드로 insert하여 출력
bfs(1)
for i in range(2,m+1):
    print(state[i])
```


### 4.3 BOJ 2178번 미로 탐색
#### 4.3.1 문제
![img](https://github.com/SEUNGYEOPOH/CV/assets/81912557/a56d700b-83a3-4bce-9dab-50e1a5008b68)

#### 4.3.2 해답
```python
from collections import deque
n, m = map(int,input().split())
board=[]
for i in range(n):
    board.append(list(map(int,input())))
# 이동량
dx = [-1,1,0,0]
dy = [0,0,-1,1]
arr = deque()
arr.append([0,0])
while arr :
  # 현재 위치
  px, py = arr.popleft()
  # 좌표 이동
  for i in range(len(dx)):
    nx = px+dx[i]
    ny = py+dy[i]
    # board를 벗어나면 continue
    if nx>n-1 or ny>m-1 or nx<0 or ny<0 :
        continue
    # 이동 가능한 좌표라면
    if board[nx][ny]==1:
        # target 좌표로 선정
        arr.append((nx,ny))
        # 좌표 값의 값을 가중하며 거리 계산
        board[nx][ny] = board[px][py]+1 # 직전 노드+1
# 가중된 거리에 따라 마지막 좌표 return
print(board[n-1][m-1])
```


### 4.4 BOJ 1697번 숨바꼭질
#### 4.4.1 문제
![숨바꼭질](https://github.com/SEUNGYEOPOH/SEUNGYEOPOH/assets/81912557/3fe26a97-b4f2-4da3-acf7-4fc287e00636)


#### 4.4.2 해답
```python
from collections import deque
import sys
input = sys.stdin.readline
n,k = map(int, input().split()) # n은 start, k는 목표 지점
data = [0 for i in range(100001)] # 최대 10만개
a=deque([n]) # start 지점 큐에 추가
ans=[]
def bfs(): 
    while len(a):
        node = a.popleft() 
        if node==k: # 만약 노드의 값이 목표 지점이라면
            ans.append(data[node]) # 정답에 추가
            break
        for nxt in (node-1, node+1, node*2): # 움직일 수 있는 방향은 총 3가지
            if nxt >= 0 and nxt <= len(data)-1: # 이동 가능 영역인 경우
                if data[nxt]==0: # 아직 방문하지 않았다면
                    data[nxt] = data[node]+1 # 1초가 지났음을 추가
                    a.append(nxt) 
bfs()
print(min(ans))
```