<!-- ---
title:  "BFS"
categories : Algorithm
tag : BFS
# 복수로 하려면 [Python, Blog]처럼 리스트 형태로 할당
toc : true
# toc순서는 markdown header(#) 기준 입니당
toc_sticky : true
toc_label : Content
toc_icon : "fas fa-book-open"
author_profile : false
use_math : true
---

# Depth First Search

## 1. What is Breadth-First Search?
- Graph Search
    - Start Node와 Graph가 주어졌을 때 Edge를 통해 방문할 수 있는 Node를 찾는 문제
    - BFS와 DFS가 존재한다.
- BFS
    - Start Node에서 인접 노드를 먼저 탐색하는 Algoritm
    - 즉 Tree를 수평으로 우선 탐색하며(Wide), Depth가 깊을수록 나중에 방문하게 됨.
<p align="center"><img src = "https://github.com/SEUNGYEOPOH/SEUNGYEOPOH/assets/81912557/b4dd16b5-68be-44cb-a6f0-a6e003108d3d" width = "50%" height = "50%" ></p>

## 2. How to Use?
- Graph 형태 구현을 위해 adjacency list 구현
    - adjacency list란?
        - Graph 표현을 위해 Edge를 공유하는 Node를 list형태로 표현한 list
        - 위의 그림의 adjacency list
        ```python
            [[1] : [2,5,9]
             [2] : [1,3]
             [3] : [2,4]
             [4] : [3]
             [5] : [1,6,8]
             [6] : [5,7]
             [7] : [6]
             [8] : [5]
             [9] : [1, 10]
             [10] : [9]
            ]
        ```
- 탐색 여부 확인을 위한 State list 구현
- Start Node를 State list에서 방문처리
- adjacency list를 통해 Edge를 공유하는 다음 Node로 이동 (Recursive Function)
- State list 상 방문처리가 된 Node라면 Skip, 아니라면 방문처리 후 탐색 반복

## 3. Base Code
### DFS
```python
n= int(input()) # Node 개수
m= int(input()) # Node간 관계
graph = [[] for i in range(n+1)] # adjacency list
state = [0 for _ in range(n+1)] # State list
for _ in range(m): 
    a,b = map(int,input().split())
    graph[a].append(b) # adjacency list에 추가
    graph[b].append(a) # adjacency list에 추가



def recur(node): # Node 탐색 용
    state[node] = 1 # start node 방문처리
    for nxt in graph[node]: # 같은 Edge를 공유하는 Node 할당
        if state[nxt] ==1: # 방문처리 된 노드?
            continue # 연산 x
        recur(nxt) # 방문 안한 곳이면 재귀호출을 통해 탐색

recur(1) # start node가 1
print(state) # 방문된 노드 출력
```

## 4. Example

### 4.1 백준 24479번
#### 4.1.1 문제
#### 4.1.2 해답
```python
import sys
sys.setrecursionlimit(150000)
input = sys.stdin.readline

n,m,r = map(int, input().split())
graph = [[] for i in range(n+1)]
state = [0 for i in range(n+1)]
cnt=1

for i in range(m):
    u,v = map(int, input().split())
    graph[v].append(u)
    graph[u].append(v)

for j in graph:
    j=sorted(j)


def recur(node):
    global cnt
    state[node] = cnt
    for nxt in sorted(graph[node]):
        if state[nxt]==0:
            cnt+=1
            recur(nxt)

recur(r)
for ans in range(1,len(state)):
    print(state[ans])
```
### 4.2 백준 24480번
#### 4.2.1 문제
#### 4.2.2 해답
```python
import sys
sys.setrecursionlimit(150000)
input = sys.stdin.readline

n,m,r = map(int, input().split())
graph = [[] for i in range(n+1)]
state = [0 for i in range(n+1)]
cnt=1

for i in range(m):
    u,v = map(int, input().split())
    graph[v].append(u)
    graph[u].append(v)

for j in graph:
    j=sorted(j, reverse=True)


def recur(node):
    global cnt
    state[node] = cnt
    for nxt in sorted(graph[node], reverse=True):
        if state[nxt]==0:
            cnt+=1
            recur(nxt)

recur(r)
for ans in range(1,len(state)):
    print(state[ans])
```
### 4.3 백준 2606번
#### 4.3.1 문제
#### 4.3.2 해답
```python
import sys
sys.setrecursionlimit(150000)
input = sys.stdin.readline

n,m,r = map(int, input().split())
graph = [[] for i in range(n+1)]
state = [0 for i in range(n+1)]
cnt=1

for i in range(m):
    u,v = map(int, input().split())
    graph[v].append(u)
    graph[u].append(v)

for j in graph:
    j=sorted(j)


def recur(node):
    global cnt
    state[node] = cnt
    for nxt in sorted(graph[node]):
        if state[nxt]==0:
            cnt+=1
            recur(nxt)

recur(r)
for ans in range(1,len(state)):
    print(state[ans])
```
### 4.2 백준 24480번
#### 4.2.1 문제
#### 4.2.2 해답
```python
n= int(input())
m= int(input())
graph = [[] for i in range(n+1)]
state = [0 for _ in range(n+1)]
for _ in range(m):
    a,b = map(int,input().split())
    graph[a].append(b)
    graph[b].append(a)


# 역주행만 제거하면 됨
def recur(node):
    state[node] = 1
    for nxt in graph[node]:
        if state[nxt] ==1:
            continue # 방문했을 case
        recur(nxt)

recur(1)
print(sum(state)-1)
```
### 4.4 백준 2644번
#### 4.4.1 문제
#### 4.4.2 해답
```python
import sys
sys.setrecursionlimit(150000)
input = sys.stdin.readline

n=int(input())

target1, target2 = map(int,input().split())
cnt=1
m=int(input())

graph = [[] for i in range(n+1)]

state = [0 for _ in range(n+1)]

for i in range(m):
    a,b = map(int, input().split())
    graph[a].append(b)
    graph[b].append(a)

def recur(node):
    global cnt
    state[node]=cnt
    
    for nxt in graph[node]:
        if state[nxt]==0:
            cnt+=1
            recur(nxt)
    cnt = cnt-1

recur(max(target1,target2))
if state[target1]!= 0 and state[target2]!=0:

    print(abs(state[target1]-state[target2]))
else:
    print(-1)
``` -->