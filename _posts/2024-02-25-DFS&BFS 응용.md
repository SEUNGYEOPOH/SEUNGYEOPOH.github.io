---
title:  "DSF & BFS 응용"
categories : Algorithm
tag : [DFS, BFS]
# 복수로 하려면 [Python, Blog]처럼 리스트 형태로 할당
toc : true
# toc순서는 markdown header(#) 기준 입니당
toc_sticky : true
toc_label : Content
toc_icon : "fas fa-book-open"
author_profile : false
use_math : true
---

# 1. DFS 문제

## 1.1 BOJ 1012번
![screencapture-acmicpc-net-problem-1012-2024-02-25-16_11_18](https://github.com/SEUNGYEOPOH/SEUNGYEOPOH/assets/81912557/d44801fa-8923-4c5b-a944-db4ee574e1d0)

### 1.1.1 구조화
- 전형적인 미로 탐색 문제
- 문제를 해결하기 위해 탐색할 board 생성
- 입력된 배추의 가로, 세로 좌표에 따라 2차원 board에서 해당 좌표값을 1로 수정
- dfs로 탐색하되, 이동은 4방향으로 가능
- 시작 지점부터 4방향 탐색 후 이동 가능영역으로 이동
- 이동할 공간이 없을 경우 False return
- 이동가능하면 방문 지점 좌표를 0으로 변경 후 True return


### 1.1.2 코드
```python
dx=(1,-1,0,0) # 이동 가능 영역 x
dy=(0,0,1,-1) # 이동 가능 영역 y

def dfs(x,y):
    if x>=n or x<=-1 or y>=m or y<=-1: # 이동 불가능하면 return False
        return False
    
    if target[x][y]==1: # 이동 가능한 지점
        target[x][y]=0 # 방문 표시
        for p in range(4):
            new_x = x+dx[p] # 4방향에 대해
            new_y = y+dy[p]
            dfs(new_x, new_y) # 이동
            
        return True # 이동 후 True

    return False 
    
n=int(input())
import sys
sys.setrecursionlimit(10000) 
for i in range(n):
    cnt = 0
    m,n,k = map(int, input().split())
    target = [[0 for x in range(m)] for q in range(n)]
    for w in range(k):
        a,b= map(int,input().split())
        target[b][a] = 1
        
    for g in range(m):
        for s in range(n):
            if dfs(s,g): # 탐색 후 연결된 이동 가능한 노드 집합의 경우
                cnt+=1 # count 증가
    print(cnt)
```

## 1.2 BOJ 1260번 DFS와 BFS

### 1.2.1 구조화
- 단순한 DFS, BFS 구현
- node 탐색 순서 출력
- 방문 여부가 변경될 때 해당 노드를 ans에 추가하여 최종 결과 Return
- 주의 : edge의 입력이 오름차 순이 아니므로 그래프를 정렬해주지 않는다면, 결과값이 달라짐.

### 1.2.2 코드
```python
from collections import deque
import sys

def dfs(node):
    state[node] = 1 # 방문 노드는 방문 처리
    ans.append(node) # 그 후 append
    for nxt in graph[node]: # 다음 노드 list
        if state[nxt]==1: # 방문 했다면 
            continue # 방문 x
        dfs(nxt) # 방문 시작

def bfs(node):
    state[node] = 1 # 노드 방문 처리
    a=deque([node]) # 방문 처리된 노드는 큐에 추가
    while len(a): # 큐가 빌 때 까지
        node = a.popleft() # FIFO원칙에 따라 큐에서 node 제거
        ans_2.append(node) # 제거된 node는 방문하기에, ans에 추가
        for nxt in graph[node]: # 다음 노드 list
            if state[nxt]==0: # 방문하지 않았을 경우
                a.append(nxt) # 큐에 추가하고
                state[nxt]=1 # 방문처리
                
n,m,l = map(int, input().split()) # 입력
graph =[[] for i in range(n+1)]
for i in range(m):
    a,b=map(int,input().split())
    graph[a].append(b)
    graph[b].append(a)

for i in range(len(graph)): # 탐색을 위해 노드 정렬
    graph[i] = sorted(graph[i])
    
state = [0 for i in range(n+1)] # dfs용 state
ans=[] # dfs 노드 방문 순서 list
ans_2=[] # bfs 노드 방문 순서 list
dfs(l) # 입력된 l노드부터 탐색
state = [0 for i in range(n+1)] # bfs용 state
bfs(l) # 입력된 l노드부터 탐색 

print(*ans) # dfs 출력
print(*ans_2) # bfs 출력
                
```

# 2. BFS 문제