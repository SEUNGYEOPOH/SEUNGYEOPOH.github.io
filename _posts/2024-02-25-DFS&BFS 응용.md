---
title:  "DSF & BFS 응용"
categories : Algorithm
tag : [DFS, BFS]
# 복수로 하려면 [Python, Blog]처럼 리스트 형태로 할당
toc : true
# toc순서는 markdown header(#) 기준 입니당
toc_sticky : true
toc_label : Content
toc_icon : "fas fa-book-open"
author_profile : false
use_math : true
---

# 1. DFS 문제

## 1.1 BOJ 1012번 유기농 배추
![screencapture-acmicpc-net-problem-1012-2024-02-25-16_11_18](https://github.com/SEUNGYEOPOH/SEUNGYEOPOH/assets/81912557/d44801fa-8923-4c5b-a944-db4ee574e1d0)

### 1.1.1 구조화
- 전형적인 미로 탐색 문제
- 문제를 해결하기 위해 탐색할 board 생성
- 입력된 배추의 가로, 세로 좌표에 따라 2차원 board에서 해당 좌표값을 1로 수정
- dfs로 탐색하되, 이동은 4방향으로 가능
- 시작 지점부터 4방향 탐색 후 이동 가능영역으로 이동
- 이동할 공간이 없을 경우 False return
- 이동가능하면 방문 지점 좌표를 0으로 변경 후 True return


### 1.1.2 코드
```python
dx=(1,-1,0,0) # 이동 가능 영역 x
dy=(0,0,1,-1) # 이동 가능 영역 y

def dfs(x,y):
    if x>=n or x<=-1 or y>=m or y<=-1: # 이동 불가능하면 return False
        return False
    
    if target[x][y]==1: # 이동 가능한 지점
        target[x][y]=0 # 방문 표시
        for p in range(4):
            new_x = x+dx[p] # 4방향에 대해
            new_y = y+dy[p]
            dfs(new_x, new_y) # 이동
            
        return True # 이동 후 True

    return False 
    
n=int(input())
import sys
sys.setrecursionlimit(10000) 
for i in range(n):
    cnt = 0
    m,n,k = map(int, input().split())
    target = [[0 for x in range(m)] for q in range(n)]
    for w in range(k):
        a,b= map(int,input().split())
        target[b][a] = 1
        
    for g in range(m):
        for s in range(n):
            if dfs(s,g): # 탐색 후 연결된 이동 가능한 노드 집합의 경우
                cnt+=1 # count 증가
    print(cnt)
```

## 1.2 BOJ 1260번 DFS와 BFS
![screencapture-acmicpc-net-problem-1260-2024-02-26-01_24_02](https://github.com/SEUNGYEOPOH/SEUNGYEOPOH/assets/81912557/fa8d0144-d53e-4b27-956a-a86b8c335173)

### 1.2.1 구조화
- 단순한 DFS, BFS 구현
- node 탐색 순서 출력
- 방문 여부가 변경될 때 해당 노드를 ans에 추가하여 최종 결과 Return
- 주의 : edge의 입력이 오름차 순이 아니므로 그래프를 정렬해주지 않는다면, 결과값이 달라짐.

### 1.2.2 코드
```python
from collections import deque
import sys

def dfs(node):
    state[node] = 1 # 방문 노드는 방문 처리
    ans.append(node) # 그 후 append
    for nxt in graph[node]: # 다음 노드 list
        if state[nxt]==1: # 방문 했다면 
            continue # 방문 x
        dfs(nxt) # 방문 시작

def bfs(node):
    state[node] = 1 # 노드 방문 처리
    a=deque([node]) # 방문 처리된 노드는 큐에 추가
    while len(a): # 큐가 빌 때 까지
        node = a.popleft() # FIFO원칙에 따라 큐에서 node 제거
        ans_2.append(node) # 제거된 node는 방문하기에, ans에 추가
        for nxt in graph[node]: # 다음 노드 list
            if state[nxt]==0: # 방문하지 않았을 경우
                a.append(nxt) # 큐에 추가하고
                state[nxt]=1 # 방문처리
                
n,m,l = map(int, input().split()) # 입력
graph =[[] for i in range(n+1)]
for i in range(m):
    a,b=map(int,input().split())
    graph[a].append(b)
    graph[b].append(a)

for i in range(len(graph)): # 탐색을 위해 노드 정렬
    graph[i] = sorted(graph[i])
    
state = [0 for i in range(n+1)] # dfs용 state
ans=[] # dfs 노드 방문 순서 list
ans_2=[] # bfs 노드 방문 순서 list
dfs(l) # 입력된 l노드부터 탐색
state = [0 for i in range(n+1)] # bfs용 state
bfs(l) # 입력된 l노드부터 탐색 

print(*ans) # dfs 출력
print(*ans_2) # bfs 출력
                
```


## 1.3 BOJ 4963번 섬의 개수
![screencapture-acmicpc-net-problem-4963-2024-02-27-17_10_44](https://github.com/SEUNGYEOPOH/SEUNGYEOPOH/assets/81912557/3f4fb448-7767-430f-85f7-d1e73b53ee50)


### 1.3.1 구조화
- 단순한 DFS 문제
- 단, 방향이 대각이동이 가능한 case
- 미로탐색, 2차원에서 중요한 point
    - 입력은 w,h 여기서 w는 가로, h는 세로
    - dfs(x,y) 형태 호출 시 x는 가로 길이(w 집합), y는 세로(h 집합) 길이와 관련
    - 2차원 배열의 행열이므로 board indexing은 [y][x]로 

### 1.3.2 코드
```python
import sys
sys.setrecursionlimit(10**6)
dx = [-1, -1, -1, 0, 0, 1, 1, 1]
dy = [-1, 0, 1, -1, 1, -1, 0, 1]

def dfs(x,y):
    if x>=w or x<=-1 or y>=h or y<=-1: # 이동 불가능하면 return False
        return False
    
    if board[y][x]==1: # 이동 가능한 지점
        board[y][x]=0 # 방문 표시
        for p in range(8):
            new_x = x+dx[p] # 4방향에 대해
            new_y = y+dy[p]
            dfs(new_x, new_y) # 이동
            
        return True # 이동 후 True

    return False 
    

while True:
    w,h = map(int, input().split())
    if w==0 and h==0:
        break
    else:
        board = []
        dx = [-1, -1, -1, 0, 0, 1, 1, 1]
        dy = [-1, 0, 1, -1, 1, -1, 0, 1]
        for i in range(h):
            data = list(map(int, input().split()))
            board.append(data)
        count = 0
        for c in range(h):
            for p in range(w):
                if dfs(p,c):
                    count+=1
        print(count)
```

# 2. BFS 문제

## 2.1 BOJ 14940번 쉬운 최단 거리
![쉬운 최단 거리](https://github.com/SEUNGYEOPOH/SEUNGYEOPOH/assets/81912557/4a35d2cf-7085-481e-b66e-560bdc041fdf)

### 2.1.1 구조화
- n은 세로(y), m은 가로(x)
- 탐색할 지도 좌표 생성
- 좌표에서 값이 0일 경우 갈 수 없음, 1일 경우 갈 수 있고, 2일 경우는 목표지점
- 갈 수 있는 좌표 중 각 좌표에서 목표지점까지의 거리를 구하는 문제
- 좌표의 값이 2인 지점이 start point
- 이를 위해 지도의 좌표를 입력받은 후 값이 2인 좌표를 큐에 추가
- 순회 시 인덱싱은 [y][x] 형태
- BFS로 탐색하되, 이동은 4방향으로 가능
- 초기 좌표가 2인 지점을 기준으로 BFS 탐색
- 현재 좌표에서 이동 가능 공간(좌표를 벗어나지 않고)임과 동시에, 좌표의 값이 0이 아닌 좌표일 경우 이전 좌표의 값에 +1씩 하며 탐색
- 시작 값이 2이므로, 탐색 후 각 좌표 값에서 2를 뺴주되, 0인 경우 이동할 수 없는 좌표이므로 Continue

### 2.1.2 코드
```python
# 1은 갈 수 있는 땅, 0은 갈 수 없는 땅, 2는 목표 지점
# n은 세로 크기, m은 가로 크기
from collections import deque
import sys
input = sys.stdin.readline
n,m = map(int, input().split()) # n은 y m은 x
mapper = []
for i in range(n):
    mapper.append(list(map(int, input().split())))
dx=(0,0,-1,1) # x 이동 가능 영역
dy=(1,-1,0,0) # y 이동 가능 영역
a=deque()
for y in range(n):
    for x in range(m):
        if mapper[y][x]==2:
            a.append([y,x]) # 좌표가 2인 경우 큐에 추가하여 Start Point로 지정
def bfs():
    while len(a):
        y,x = a.popleft() # init은 목표 지점인 2에서부터 시작
        for i in range(4): 
            new_x = x+dx[i] # 이동 가능한 x좌표
            new_y = y+dy[i] # 이동 가능한 y좌표
            if new_x>=m or new_y >=n or new_x<=-1 or new_y <= -1: # 보드의 크기를 벗어나면 continue
                continue
            else:
                if mapper[new_y][new_x]==1: # 현재지점에서 이동가능한 좌표가 1일 경우
                    mapper[new_y][new_x] = mapper[y][x]+1 # 이전 좌표값에 1을 더하여 거리 계산
                    a.append([new_y,new_x]) # 이동 가능한 공간을 다시 큐에 push
bfs()
for i in range(len(mapper)):
    for j in range(len(mapper[i])):
        if mapper[i][j]==0: # 좌표 값이 0인 경우는 이동 불가능하므로 continue
            continue
        else:
            mapper[i][j]= mapper[i][j]-2 # 초기 시작 지점이 2이므로, 모두 -2하여 출력
for c in mapper:
    print(*c)
```



## 2.2 BOJ 7576번 토마토
![도마도](https://github.com/SEUNGYEOPOH/SEUNGYEOPOH/assets/81912557/92e3f71b-0172-450f-a69a-261fc334c4dc)

### 2.2.1 구조화
- 앞 선 문제와 유사함.
- 탐색할 토마토 좌표 생성
- 익은 토마토는 1, 안익은 토마토는 0
- 익은 토마토가 안익은 토마토에게 영향을 주므로, 시작 지점은 이미 익어있는 토마토
- 이를 위해 토마토들의 좌표를 입력받은 후 값이 1인 토마토의 좌표를 큐에 추가
- 순회 시 인덱싱은 [y][x] 형태
- BFS로 탐색하되, 이동은 4방향으로 가능
- 초기 좌표가 1인 토마토를 기준으로 BFS 탐색
- 현재 좌표가 1이고, 이동 가능 공간의 좌표가 0일 경우 1씩 증가하여 tomato 값 수정
- start가 1이므로 -1하여 출력


### 2.2.2 코드
```python
from collections import deque
import sys
input = sys.stdin.readline
m,n = map(int, input().split())
tomato = []
a=deque()
for i in range(n):
    data = list(map(int, input().split())) 
    tomato.append(data)
for i in range(n): # y
    for j in range(m): # x
        if tomato[i][j]==1:
            a.append([i,j]) # 미리 다른 지점의 영향을 끼치는 익은 토마토의 위치를 큐에 저장
            
dx=(0,0,-1,1) # x 이동 가능 영역
dy=(1,-1,0,0) # y 이동 가능 영역
def bfs():
    while len(a): 
        y,x = a.popleft() # 익은 토마토인 1의 좌표를 기준으로 BFS 시작
        for i in range(4):
            new_x = x+dx[i] # 이동 가능한 x좌표
            new_y = y+dy[i] # 이동 가능한 y좌표
            if new_x>=m or new_y >=n or new_x<=-1 or new_y <= -1: # 이동가능영역이 아닌 경우 밑에 코드 무시
                continue
            else:
                if tomato[new_y][new_x]==0: # 이동 가능한 지점 중 아직 익지 않은 경우
                    tomato[new_y][new_x] = tomato[y][x]+1 # 익은 토마토를 기점으로 1씩 추가
                    a.append([new_y,new_x]) # 새로 익은 토마토의 좌표를 큐에 추가
bfs()
ans=0 # 정답 초기화
for i in tomato:
    if 0 in i: # 익지 않은 토마토가 존재한 경우 다 채울 수 없는 Case
        ans=0 # 하루를 빼주기 떄문에 -1을 출력하기 위해 0대입 후 반복문 탈출
        break
    else:
        ans = max(max(i),ans) # 다 채워진 토마토 판을 순회하며 max값 도출
print(ans-1) # 시작 토마토의 값이 1이므로, 하루를 빼줘야 함.
```

## 2.3 BOJ 13549번 숨바꼭질 3
![숨바꼭질 3](https://github.com/SEUNGYEOPOH/SEUNGYEOPOH/assets/81912557/f62d5f84-8979-4c60-ab3e-b35efb3cdda8)


### 2.3.1 구조화
- BFS에서 풀었던 숨바꼭질 문제의 심화버전
- 모든 조건은 동일하나, 순간이동의 경우 0초 추가
- 단순히 조건을 걸어 해결하려 했으나, 시간초과 발생
    - 최단거리 문제이므로, 0초 이동 선택지는 최우선순위로 큐에 추가(appendleft)
    - 순간이동이 0초이므로, 초기화를 0으로 했다면 중복으로 인해 시간초과 발생
- 이후 -1로 초기화 후 진행하여 문제 해결


### 2.3.3 코드
```python
from collections import deque
import sys
input = sys.stdin.readline
n,k = map(int, input().split())
data = [-1 for i in range(100001)] # 최대 범위, 0으로 초기화한다면, 방문 가능 여부에서 순간 이동 시 중복으로 인해, 시간초과 발생. -1로 초기화
a=deque([n]) # 추가
data[n]=0
ans=[]
def bfs():
    while len(a):
        node = a.popleft()
        if node==k:
            ans.append(data[node])
        for nxt in (node-1, node+1, node*2): # 이동 가능 영역
            if nxt >= 0 and nxt <= len(data)-1:
                if nxt==node*2: # 순간이동을 진행했을 때
                    if data[nxt]==-1: # 방문하지 않은 경우
                        data[nxt] = data[node] # 0초 추가
                        a.appendleft(nxt) # 최단거리 문제이므로, 0초가 우선으로 큐에 추가
                else:
                    if data[nxt]==-1: # 일반적인 이동일 경우
                        data[nxt] = data[node]+1 # 1초 추가
                        a.append(nxt)
bfs()
print(min(ans))
```