---
title:  "DFS"
categories : Algorithm
tag : DFS
# 복수로 하려면 [Python, Blog]처럼 리스트 형태로 할당
toc : true
# toc순서는 markdown header(#) 기준 입니당
toc_sticky : true
toc_label : Content
toc_icon : "fas fa-book-open"
author_profile : false
use_math : true
---

# Depth First Search

## 1. What is Depth First Search?
- Graph Search
    - Start Node와 Graph가 주어졌을 때 Edge를 통해 방문할 수 있는 Node를 찾는 문제
    - BFS와 DFS가 존재한다.
- DFS
    - Start Node에서 Depth를 기준으로 탐색
    - 즉 Tree를 수직으로 우선 탐색하며 leaf node에 다다르면, 같은 Edge를 공유하는 동일 Depth 상 노드를 탐색

<p align="center"><img src = "https://github.com/SEUNGYEOPOH/SEUNGYEOPOH/assets/81912557/b1f6a1c9-fa61-4977-9107-cd161700cf21" width = "50%" height = "50%" ></p>

## 2. How to Use?
- Graph 형태 구현을 위해 adjacency list 구현
    - adjacency list란?
        - Graph 표현을 위해 Edge를 공유하는 Node를 list형태로 표현한 list
        - 위의 그림의 adjacency list
        ```python
            [[1] : [2,5,9]
             [2] : [1,3]
             [3] : [2,4]
             [4] : [3]
             [5] : [1,6,8]
             [6] : [5,7]
             [7] : [6]
             [8] : [5]
             [9] : [1, 10]
             [10] : [9]
            ]
        ```
- 탐색 여부 확인을 위한 State list 구현
- Start Node를 State list에서 방문처리
- adjacency list를 통해 Edge를 공유하는 다음 Node로 이동 (Recursive Function)
- State list 상 방문처리가 된 Node라면 Skip, 아니라면 방문처리 후 탐색 반복
- 참고로 Python의 maximum recursion depth는 default가 1000이다.
    - 추가적인 탐색을 원할경우 sys.setrecursionlimit(value)를 통해 늘릴 수 있다.

## 3. Base Code
### DFS
```python
n= int(input()) # Node 개수
m= int(input()) # Node간 관계
graph = [[] for i in range(n+1)] # adjacency list
state = [0 for _ in range(n+1)] # State list
for _ in range(m): 
    a,b = map(int,input().split())
    graph[a].append(b) # adjacency list에 추가
    graph[b].append(a) # adjacency list에 추가



def recur(node): # Node 탐색 용
    state[node] = 1 # start node 방문처리
    for nxt in graph[node]: # 같은 Edge를 공유하는 Node 할당
        if state[nxt] ==1: # 방문처리 된 노드?
            continue # 연산 x
        recur(nxt) # 방문 안한 곳이면 재귀호출을 통해 탐색

recur(1) # start node가 1
print(state) # 방문된 노드 출력
```

## 4. Example

### 4.1 백준 24479번
#### 4.1.1 문제
![screencapture-acmicpc-net-problem-24479-2024-01-07-01_01_09](https://github.com/SEUNGYEOPOH/SEUNGYEOPOH/assets/81912557/da846d57-b18a-49d7-bdb2-73982099bfcc)

#### 4.1.2 해답
```python
import sys
sys.setrecursionlimit(150000) 
input = sys.stdin.readline 

n,m,r = map(int, input().split())
graph = [[] for i in range(n+1)]
state = [0 for i in range(n+1)]
cnt=1

for i in range(m):
    u,v = map(int, input().split())
    graph[v].append(u)
    graph[u].append(v)

for j in graph:
    j=sorted(j)


def recur(node):
    global cnt
    state[node] = cnt
    for nxt in sorted(graph[node]):
        if state[nxt]==0:
            cnt+=1
            recur(nxt)

recur(r)
for ans in range(1,len(state)):
    print(state[ans])
```
### 4.2 백준 24480번

#### 4.2.1 문제
![screencapture-acmicpc-net-problem-24480-2024-01-07-01_02_22](https://github.com/SEUNGYEOPOH/SEUNGYEOPOH/assets/81912557/ea8cf7b0-cda3-4621-9810-b914a487c105)

#### 4.2.2 해답
```python
import sys
sys.setrecursionlimit(150000)
input = sys.stdin.readline

n,m,r = map(int, input().split())
graph = [[] for i in range(n+1)]
state = [0 for i in range(n+1)]
cnt=1

for i in range(m):
    u,v = map(int, input().split())
    graph[v].append(u)
    graph[u].append(v)

for j in graph:
    j=sorted(j, reverse=True)


def recur(node):
    global cnt
    state[node] = cnt
    for nxt in sorted(graph[node], reverse=True):
        if state[nxt]==0:
            cnt+=1
            recur(nxt)

recur(r)
for ans in range(1,len(state)):
    print(state[ans])
```
### 4.3 백준 2606번

#### 4.3.1 문제
![screencapture-acmicpc-net-problem-2606-2024-01-07-01_04_12](https://github.com/SEUNGYEOPOH/SEUNGYEOPOH/assets/81912557/9a5c533b-563e-45ef-9800-2363ed7cbd26)

#### 4.3.2 해답
```python
import sys
sys.setrecursionlimit(150000)
input = sys.stdin.readline

n,m,r = map(int, input().split())
graph = [[] for i in range(n+1)]
state = [0 for i in range(n+1)]
cnt=1

for i in range(m):
    u,v = map(int, input().split())
    graph[v].append(u)
    graph[u].append(v)

for j in graph:
    j=sorted(j)


def recur(node):
    global cnt
    state[node] = cnt
    for nxt in sorted(graph[node]):
        if state[nxt]==0:
            cnt+=1
            recur(nxt)

recur(r)
for ans in range(1,len(state)):
    print(state[ans])
```

### 4.4 백준 2644번
#### 4.4.1 문제
![screencapture-acmicpc-net-problem-2644-2024-01-07-01_05_36](https://github.com/SEUNGYEOPOH/SEUNGYEOPOH/assets/81912557/1cee3c1b-4753-4b5b-a5ca-ba2d6d52c301)
#### 4.4.2 해답
```python
import sys
sys.setrecursionlimit(150000)
input = sys.stdin.readline

n=int(input())

target1, target2 = map(int,input().split())
cnt=1
m=int(input())

graph = [[] for i in range(n+1)]

state = [0 for _ in range(n+1)]

for i in range(m):
    a,b = map(int, input().split())
    graph[a].append(b)
    graph[b].append(a)

def recur(node):
    global cnt
    state[node]=cnt
    
    for nxt in graph[node]:
        if state[nxt]==0:
            cnt+=1
            recur(nxt)
    cnt = cnt-1

recur(max(target1,target2))
if state[target1]!= 0 and state[target2]!=0:

    print(abs(state[target1]-state[target2]))
else:
    print(-1)
```

### 4.5 백준 2644번
#### 4.5.1 문제
![screencapture-acmicpc-net-problem-11724-2024-02-25-02_15_56](https://github.com/SEUNGYEOPOH/SEUNGYEOPOH/assets/81912557/d437bc16-106d-4956-b96f-afb5ae746aab)

#### 4.5.2 해답
```python
import sys
sys.setrecursionlimit(10**6)
input = sys.stdin.readline

n,m = map(int, input().split())
graph = [[] for i in range(n+1)]
state = [False for _ in range(n+1)]
for i in range(m):
    a,b = map(int, input().split())
    graph[a].append(b)
    graph[b].append(a)

def dfs(node):
    state[node]=True
    
    for nxt in graph[node]:
        if state[nxt]==False:
            state[nxt]=True
            dfs(nxt)

count = 0
for i in range(1, n+1):
    if state[i] == False: # Start
        count += 1 # count 증가
        dfs(i) # 재귀 형태로 연결된 모든 노드 방문, 즉 state가 변하지 않는 값의 경우 다음 Loop에서 검출되는 Process
        
print(count)
```